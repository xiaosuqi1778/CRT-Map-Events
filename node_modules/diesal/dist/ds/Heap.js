"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Gets the index of the parent of the given index in the heap-array.
 */
function getParent(index) {
    return Math.floor((index - 1) / 2);
}
/**
 * Gets the indexes of the children of the node at the given index.
 */
function getChildren(index) {
    return [2 * index + 1, 2 * index + 2];
}
/**
 * A Heap is a data structure that satisfies the *heap property*: if A is
 * a parent node of B, then the value of node A is ordered with respect to the
 * value of B, with the same ordering applying across all nodes. Heaps are an
 * implementation of a Priority Queue, providing fast (O(1)) access to the min,
 * and reasonable (O(logn) or better, depending on variant) performance for
 * insert and delete.
 *
 * This particular implementation is of a binary heap, where each node has 0-2
 * children.
 *
 * For more information:
 *
 * [Heaps][Heap]
 *
 * [Binary Heaps][BinHeap]
 *
 * Note that in all descriptions, where we use "min", it really depends on what
 * your comparison function is. The default is a min function.
 *
 * [Heap]: https://en.wikipedia.org/wiki/Heap_(data_structure)
 * [BinHeap]: https://en.wikipedia.org/wiki/Binary_heap
 */
var Heap = /** @class */ (function () {
    function Heap(list, cmp) {
        if (list === void 0) { list = []; }
        if (cmp === void 0) { cmp = function (a, b) { return a < b; }; }
        this.cmp = cmp;
        this.heap = list;
        for (var i = Math.floor(this.heap.length / 2) - 1; i >= 0; i--) {
            this.heapify(i);
        }
    }
    Object.defineProperty(Heap.prototype, "size", {
        /**
         * The number of elements in the heap
         *
         * @type {number}
         */
        get: function () {
            return this.heap.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Insert a new element into the heap, maintaining the heap property.
     */
    Heap.prototype.push = function (value) {
        var index = this.heap.push(value) - 1;
        var check = true;
        while (check) {
            var parent_1 = getParent(index);
            if (parent_1 >= 0 && this.cmp(value, this.heap[parent_1])) {
                this.swap(index, parent_1);
                index = parent_1;
            }
            else {
                check = false;
            }
        }
        return this.size;
    };
    /**
     * Gets the min value and removes it from the heap, adjusting everything else
     * in the heap to maintain heap property, then returns the value.
     */
    Heap.prototype.pop = function () {
        // remove and store lowest value
        var min = this.heap.shift();
        if (typeof min === 'undefined') {
            return null;
        }
        var tail = this.heap.pop();
        if (tail) {
            this.heap.unshift(tail);
            this.heapify();
        }
        return min;
    };
    /**
     * Checks if the value is inside the collection
     */
    Heap.prototype.contains = function (value) {
        return this.heap.indexOf(value) >= 0;
    };
    /**
     * Iteratively goes through tree, ensuring heap property is maintained,
     * correcting it if not.
     */
    Heap.prototype.heapify = function (i) {
        var _this = this;
        if (i === void 0) { i = 0; }
        // if this breaks the heap property, fix it. rinse and repeat until heap
        // property is true.
        var len = this.heap.length;
        var largest = i;
        getChildren(i).forEach(function (child) {
            if (child < len && _this.cmp(_this.heap[child], _this.heap[largest])) {
                largest = child;
            }
        });
        if (largest !== i) {
            this.swap(largest, i);
            this.heapify(largest);
        }
    };
    /**
     * Swaps two indexes in the heap.
     */
    Heap.prototype.swap = function (a, b) {
        var _a;
        ;
        _a = __read([this.heap[b], this.heap[a]], 2), this.heap[a] = _a[0], this.heap[b] = _a[1]; // eslint-disable-line
    };
    /**
     * Gets the min value of the heap (if your cmp function is a less-than
     * comparison).
     */
    Heap.prototype.findMin = function () {
        return this.heap[0];
    };
    /**
     * Gets the max value of the heap (if your cmp function is a greater-than
     * comparison). (Functionally, identical to findMin -- included for semantic
     * reasons based on comparison function)
     */
    Heap.prototype.findMax = function () {
        return this.heap[0];
    };
    return Heap;
}());
exports.Heap = Heap;
