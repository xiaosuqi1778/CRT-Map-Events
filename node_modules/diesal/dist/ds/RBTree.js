"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var BinarySearchTree_1 = require("./BinarySearchTree");
var utils_1 = require("../utils");
/**
 * A Red-Black Tree is a binary search tree that assigns a color to each node
 * (red or black; hence the name). In addition, it maintains these properties:
 *
 * 1. The root is black.
 * 2. Every leaf is black.
 * 3. If a node is red, then both its children are black.
 * 4. For each node, all simple paths from the node to its descendant leaves
 *    contain the same number of black nodes.
 *
 * These properties ensure that the tree is balanced (or close to it) -- in
 * other words, the number of children in the left branch of a node is going to
 * be approximately equal to the number of children in the right branch of the
 * node.
 *
 * Note: Property (2) is implicit; we do not actually create empty nodes and
 * mark them specifically as black in this implementation.
 */
var RBTree = /** @class */ (function (_super) {
    __extends(RBTree, _super);
    function RBTree(value, cmp, eq) {
        if (cmp === void 0) { cmp = function (a, b) { return a < b; }; }
        if (eq === void 0) { eq = function (a, b) { return a === b; }; }
        var _this = _super.call(this, value, cmp) || this;
        _this.cmp = cmp;
        _this.eq = eq;
        _this.isRed = false;
        return _this;
    }
    Object.defineProperty(RBTree.prototype, "color", {
        get: function () {
            if (this.isRed)
                return 'red';
            return 'black';
        },
        enumerable: true,
        configurable: true
    });
    RBTree.fromArray = function (arr, cmp) {
        if (arr.length === 0)
            return undefined;
        var root = new RBTree(arr[0], cmp);
        for (var i = 1; i < arr.length; i++) {
            root.insert(arr[i]);
        }
        return root;
    };
    RBTree.prototype.prettyPrintValue = function () {
        if (this.isRed)
            return "\u001B[31m" + this.value + "\u001B[0m";
        return "" + this.value;
    };
    RBTree.prototype.rotateLeft = function (node) {
        utils_1.assert(node.right);
        // Shuffle around values to account for moving node
        var parentValue = node.value;
        var parentRed = node.isRed;
        var child = node.right;
        node.right = child.right;
        if (node.right)
            node.right.parent = node;
        child.right = child.left;
        child.left = node.left;
        if (child.left)
            child.left.parent = child;
        node.left = child;
        node.value = child.value;
        child.value = parentValue;
        node.isRed = child.isRed;
        child.isRed = parentRed;
    };
    RBTree.prototype.rotateRight = function (node) {
        utils_1.assert(node.left);
        var parentValue = node.value;
        var parentRed = node.isRed;
        var child = node.left;
        node.left = child.left;
        if (node.left)
            node.left.parent = node;
        child.left = child.right;
        child.right = node.right;
        if (child.right)
            child.right.parent = child;
        node.right = child.withParent(node);
        node.value = child.value;
        child.value = parentValue;
        node.isRed = child.isRed;
        child.isRed = parentRed;
    };
    RBTree.prototype.insertFixup = function (newNode) {
        var _a;
        var curNode = newNode;
        var nodeInPlace = newNode;
        while (((_a = curNode.parent) === null || _a === void 0 ? void 0 : _a.parent) && curNode.parent.isRed) {
            if (curNode.parent.isLeftChild) {
                var uncle = curNode.parent.parent.right;
                if (uncle === null || uncle === void 0 ? void 0 : uncle.isRed) {
                    curNode.parent.isRed = false;
                    uncle.isRed = false;
                    curNode.parent.parent.isRed = true;
                    curNode = curNode.parent.parent;
                }
                else {
                    if (curNode.isRightChild) {
                        curNode = curNode.parent;
                        this.rotateLeft(curNode);
                        if (curNode.left === nodeInPlace)
                            nodeInPlace = curNode;
                        curNode = curNode.left; // eslint-disable-line
                    }
                    utils_1.assert(curNode.parent);
                    utils_1.assert(curNode.parent.parent);
                    curNode.parent.isRed = false;
                    curNode.parent.parent.isRed = true;
                    this.rotateRight(curNode.parent.parent);
                    if (curNode.parent.right === nodeInPlace) {
                        nodeInPlace = curNode.parent;
                    }
                }
            }
            else {
                var uncle = curNode.parent.parent.left;
                if (uncle === null || uncle === void 0 ? void 0 : uncle.isRed) {
                    curNode.parent.isRed = false;
                    uncle.isRed = false;
                    curNode.parent.parent.isRed = true;
                    curNode = curNode.parent.parent;
                }
                else {
                    if (curNode.isLeftChild) {
                        curNode = curNode.parent;
                        this.rotateRight(curNode);
                        if (curNode.right === nodeInPlace)
                            nodeInPlace = curNode;
                        curNode = curNode.right; // eslint-disable-line
                    }
                    utils_1.assert(curNode.parent);
                    utils_1.assert(curNode.parent.parent);
                    curNode.parent.isRed = false;
                    curNode.parent.parent.isRed = true;
                    this.rotateLeft(curNode.parent.parent);
                    if (curNode.parent.left === nodeInPlace) {
                        nodeInPlace = curNode.parent;
                    }
                }
            }
        }
        this.isRed = false;
        return nodeInPlace;
    };
    RBTree.prototype.insert = function (value) {
        this.insertAndReturnNode(value);
        return this;
    };
    RBTree.prototype.insertAndReturnNode = function (value) {
        var _a = __read(this.findParentAndSideFor(value), 2), node = _a[0], side = _a[1];
        utils_1.assert(node instanceof RBTree, 'Mixed tree types');
        var newNode = new RBTree(value, this.cmp).withParent(node);
        newNode.isRed = true;
        node[side] = newNode;
        return this.insertFixup(newNode);
    };
    RBTree.prototype.transplant = function (a, b) {
        if (!a.parent) {
            if (b) {
                this.isRed = b.isRed;
                this.value = b.value;
                this.left = b.left;
                this.right = b.right;
                b.parent = a.parent;
            }
        }
        else if (a.isLeftChild) {
            a.parent.left = b === null || b === void 0 ? void 0 : b.withParent(a.parent);
        }
        else {
            a.parent.right = b === null || b === void 0 ? void 0 : b.withParent(a.parent);
        }
    };
    RBTree.prototype.deleteFixup = function (parent, side) {
        var _a, _b, _c, _d, _e, _f, _g;
        var curParent = parent;
        var curSide = side;
        while (curParent && !((_a = curParent[curSide]) === null || _a === void 0 ? void 0 : _a.isRed)) {
            if (curSide === 'left') {
                var w = curParent.right;
                if (w === null || w === void 0 ? void 0 : w.isRed) {
                    w.isRed = false;
                    curParent.isRed = true;
                    this.rotateLeft(curParent);
                    curParent = curParent.left; // eslint-disable-line
                    w = curParent.right;
                }
                utils_1.assert(w);
                if (!((_b = w.left) === null || _b === void 0 ? void 0 : _b.isRed) && !((_c = w.right) === null || _c === void 0 ? void 0 : _c.isRed)) {
                    w.isRed = true;
                    curSide = (curParent === null || curParent === void 0 ? void 0 : curParent.isLeftChild) ? 'left' : 'right';
                    curParent = curParent.parent;
                }
                else {
                    if (!((_d = w.right) === null || _d === void 0 ? void 0 : _d.isRed)) {
                        if (w.left)
                            w.left.isRed = false;
                        w.isRed = true;
                        this.rotateRight(w);
                        w = curParent.right;
                    }
                    utils_1.assert(w);
                    w.isRed = curParent.isRed;
                    curParent.isRed = false;
                    if (w.right)
                        w.right.isRed = false;
                    this.rotateLeft(curParent);
                    curParent = undefined;
                    this.isRed = false;
                }
            }
            else {
                var w = curParent.left;
                if (w === null || w === void 0 ? void 0 : w.isRed) {
                    w.isRed = false;
                    curParent.isRed = true;
                    this.rotateRight(curParent);
                    curParent = curParent.right; // eslint-disable-line
                    w = curParent.left;
                }
                utils_1.assert(w, 'w must be defined');
                if (!((_e = w.right) === null || _e === void 0 ? void 0 : _e.isRed) && !((_f = w.left) === null || _f === void 0 ? void 0 : _f.isRed)) {
                    w.isRed = true;
                    curSide = curParent.isLeftChild ? 'left' : 'right';
                    curParent = curParent.parent;
                }
                else {
                    if (!((_g = w.left) === null || _g === void 0 ? void 0 : _g.isRed)) {
                        if (w.right)
                            w.right.isRed = false;
                        w.isRed = true;
                        this.rotateLeft(w);
                        w = curParent.left;
                    }
                    utils_1.assert(w);
                    w.isRed = curParent.isRed;
                    curParent.isRed = false;
                    if (w.left)
                        w.left.isRed = false;
                    this.rotateRight(curParent);
                    curParent = undefined;
                    this.isRed = false;
                }
            }
        }
        if (curParent) {
            var curNode = curParent[curSide];
            if (curNode)
                curNode.isRed = false;
        }
        else {
            this.isRed = false;
        }
    };
    RBTree.prototype.remove = function (value) {
        var node = this.search(value);
        if (!node || !(node instanceof RBTree))
            return this;
        var nodel = node.left;
        var noder = node.right;
        var nodeir = node.isRed;
        var curNode = node;
        var curNodeOriginallyRed = curNode.isRed;
        var xP;
        var xS = 'left';
        if (!nodel) {
            xP = node === this ? undefined : node;
            xS = 'right';
            if (!noder && !node.parent) {
                return undefined;
            }
            if (!noder) {
                xP = node.parent;
                xS = node.isLeftChild ? 'left' : 'right';
            }
            this.transplant(node, noder);
        }
        else if (!noder) {
            xP = node === this ? undefined : node;
            xS = 'left';
            this.transplant(node, nodel);
        }
        else {
            curNode = noder.leftmostDescendant;
            curNodeOriginallyRed = curNode.isRed;
            xP = curNode;
            xS = 'right';
            if (curNode.parent === node) {
                var x = xP[xS];
                if (x)
                    x.parent = curNode;
            }
            else {
                this.transplant(curNode, curNode.right);
                xP = curNode.parent;
                xS = 'left';
                curNode.right = noder.withParent(curNode);
            }
            this.transplant(node, curNode);
            if (node === this) {
                this.left = nodel.withParent(this);
                if (curNode.right)
                    this.right = curNode.right.withParent(this);
                this.isRed = nodeir;
                if (xP === curNode) {
                    xP = this;
                }
            }
            else {
                curNode.left = nodel.withParent(curNode);
                curNode.isRed = nodeir;
            }
        }
        if (!curNodeOriginallyRed) {
            this.deleteFixup(xP, xS);
        }
        return this;
    };
    return RBTree;
}(BinarySearchTree_1.BinarySearchTree));
exports.RBTree = RBTree;
