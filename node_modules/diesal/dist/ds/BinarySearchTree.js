"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("../utils");
var BinaryTree_1 = require("./BinaryTree");
/**
 * A binary search tree is a tree where each node has (at most) two children and
 * the values are sorted. Note that this does not necessarily mean the tree is
 * _balanced_ (see `RBTree` for that), so in the worst case you could have a
 * tree whose depth is the same as its size, meaning worse performance than a
 * simple list.
 */
var BinarySearchTree = /** @class */ (function (_super) {
    __extends(BinarySearchTree, _super);
    function BinarySearchTree(value, cmp, eq) {
        if (cmp === void 0) { cmp = function (a, b) { return a < b; }; }
        if (eq === void 0) { eq = function (a, b) { return a === b; }; }
        var _this = _super.call(this, value) || this;
        _this.cmp = cmp;
        _this.eq = eq;
        return _this;
    }
    BinarySearchTree.fromArray = function (arr, cmp, eq) {
        if (arr.length === 0)
            return undefined;
        var root = new BinarySearchTree(arr[0], cmp, eq);
        for (var i = 1; i < arr.length; i++) {
            root.insert(arr[i]);
        }
        return root;
    };
    BinarySearchTree.prototype.findParentAndSideFor = function (value) {
        var curNode = this; // eslint-disable-line
        while (true) { // eslint-disable-line
            if (this.cmp(value, curNode.value)) {
                if (curNode.left)
                    curNode = curNode.left;
                else
                    return [curNode, 'left'];
            }
            else {
                if (curNode.right)
                    curNode = curNode.right;
                else
                    return [curNode, 'right'];
            }
        }
    };
    BinarySearchTree.prototype.insert = function (value) {
        var _a = __read(this.findParentAndSideFor(value), 2), node = _a[0], side = _a[1];
        node[side] = new BinarySearchTree(value, this.cmp, this.eq).withParent(node);
        return this;
    };
    /**
     * Search for a value in the tree.
     */
    BinarySearchTree.prototype.search = function (value) {
        var curNode = this; // eslint-disable-line
        while (curNode && typeof curNode.value !== 'undefined') {
            if (this.eq(curNode.value, value))
                return curNode;
            if (this.cmp(value, curNode.value))
                curNode = curNode.left;
            else
                curNode = curNode.right;
        }
        return undefined;
    };
    /**
     * Checks if the given value is in the tree.
     *
     * @param {*} value The value to check for
     * @returns {boolean} Whether or not the value is in the collection
     */
    BinarySearchTree.prototype.contains = function (value) {
        return Boolean(this.search(value));
    };
    /**
     * Removes a value from the tree. If the value is in the tree multiple times,
     * it will remove the first one found.
     */
    BinarySearchTree.prototype.remove = function (value) {
        // First, find the node.
        var node = this.search(value);
        // If it doesn't exist in the tree, we can exit.
        if (!node) {
            return this;
        }
        // If the node to be removed is the root node, we need a temporary parent as
        // a placeholder for the impending node shuffle.
        var rootParent = null;
        if (node === this && !this.parent) {
            this.parent = new BinarySearchTree(this.value, this.cmp, this.eq);
            this.parent.left = this.withParent(this.parent);
            rootParent = this.parent;
        }
        utils_1.assert(node.parent !== undefined);
        // If it has both left and right children, we need to do some extra work.
        // Find the next higher value (the right subtree's leftmost descendant),
        // swap out the values, and remove the other node.
        //    (D)               (S)
        //   /  \     =>       /  \
        // (L)  (R)          (L)  (R)
        //     /  \              /  \
        //  (S)   (E)          (C)  (E)
        //     \
        //    (C)
        if (node.left && node.right) {
            var successor = node.right.leftmostDescendant;
            node.value = successor.value;
            var successorParent = successor.parent;
            // If the successor node is the right child of its parent, replace it
            // with its own right children (if any). This can only happen if the
            // successor is the direct child of the node being removed.
            var nodeSide = successorParent.left === successor ? 'left' : 'right';
            successorParent[nodeSide] = successor.right;
            if (successor.right) {
                successor.right.parent = successorParent;
            }
        }
        else {
            // If it only has one child, then we just replace it with its own child.
            // If it has no children, we can just remove it. This condition is rolled
            // into the final else, since with no children, `node.right` is `null`.
            var nodeParent = node.parent;
            var nodeSide = nodeParent.left === node ? 'left' : 'right';
            if (node.left) {
                nodeParent[nodeSide] = node.left;
                // Don't forget to reset parents
                node.left.parent = node.parent;
            }
            else {
                nodeParent[nodeSide] = node.right;
                // Don't forget to reset parents
                if (node.right) {
                    node.right.parent = node.parent;
                }
            }
        }
        if (rootParent) {
            if (rootParent.left) {
                return rootParent.left.withoutParent();
            }
            return undefined;
        }
        return this;
    };
    /**
     * Finds the immediate predecessor of the given value
     */
    BinarySearchTree.prototype.getPredecessor = function (value) {
        return this.getNeighbor(value, true);
    };
    /**
     * Finds the immediate successor of the given value
     */
    BinarySearchTree.prototype.getSuccessor = function (value) {
        return this.getNeighbor(value, false);
    };
    /**
     * Finds the immediate predecessor or successor of the given value
     */
    BinarySearchTree.prototype.getNeighbor = function (value, findPredecessor) {
        var foundNode = this.search(value);
        if (!foundNode) {
            return undefined;
        }
        var sideToCheck;
        var descendant;
        if (findPredecessor) {
            sideToCheck = 'left';
            descendant = 'rightmostDescendant';
        }
        else {
            sideToCheck = 'right';
            descendant = 'leftmostDescendant';
        }
        if (foundNode[sideToCheck]) {
            return foundNode[sideToCheck][descendant].value;
        }
        while (foundNode &&
            foundNode.parent &&
            foundNode.parent[sideToCheck] === foundNode) {
            foundNode = foundNode.parent;
        }
        if (!foundNode.parent) {
            return undefined;
        }
        return foundNode.parent.value;
    };
    return BinarySearchTree;
}(BinaryTree_1.BinaryTree));
exports.BinarySearchTree = BinarySearchTree;
