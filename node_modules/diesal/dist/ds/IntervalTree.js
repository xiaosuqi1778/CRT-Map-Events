"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var RBTree_1 = require("./RBTree");
function recalculateMax(node) {
    var max = node.value.high;
    if (node.left)
        max = Math.max(max, node.left.value.max);
    if (node.right)
        max = Math.max(max, node.right.value.max);
    node.value.max = max;
    return max;
}
/**
 * An interval tree is a data structure that holds intervals. For example, if
 * you had events which took place over a period of time, you might store them
 * in an interval tree where the interval is their duration.
 *
 * It allows you to find all intervals which contain a specific point, or
 * overlap with a given interval.
 */
var IntervalTree = /** @class */ (function () {
    /**
     * Constructs an empty interval tree.
     */
    function IntervalTree(eq) {
        if (eq === void 0) { eq = function (a, b) { return a === b; }; }
        this.eq = eq;
        this._size = 0;
        this.tree = undefined;
    }
    Object.defineProperty(IntervalTree.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    IntervalTree.prototype.insert = function (low, high, value) {
        var _this = this;
        var interval = {
            low: low,
            high: high,
            value: value,
            max: high,
        };
        if (!this.tree) {
            this.tree = new RBTree_1.RBTree(interval, function (a, b) { return a.low < b.low; }, function (a, b) {
                return a.low === b.low && a.high === b.high && _this.eq(a.value, b.value);
            });
        }
        else {
            var node = this.tree.insertAndReturnNode(interval);
            if (node.left)
                recalculateMax(node.left);
            if (node.right)
                recalculateMax(node.right);
            recalculateMax(node);
            while (node.parent) {
                recalculateMax(node.parent);
                node = node.parent;
            }
        }
        this._size++;
        return this;
    };
    IntervalTree.prototype.remove = function (low, high, value) {
        if (this.tree) {
            this.tree.remove({ low: low, high: high, value: value, max: high });
        }
        return this;
    };
    IntervalTree.prototype.lookup = function (position) {
        if (!this.tree)
            return [];
        var overlaps = [];
        var stack = [this.tree];
        while (stack.length) {
            var node = stack.pop();
            if (!node)
                continue;
            if (node.value.low <= position && node.value.high >= position) {
                overlaps.push(node.value.value);
            }
            if (node.left && node.left.value.max >= position)
                stack.push(node.left);
            if (node.right &&
                node.value.low <= position &&
                node.right.value.max >= position) {
                stack.push(node.right);
            }
        }
        return overlaps;
    };
    IntervalTree.prototype.overlap = function (low, high) {
        if (!this.tree)
            return [];
        var overlaps = [];
        var stack = [this.tree];
        while (stack.length) {
            var node = stack.pop();
            if (!node)
                continue;
            if (low <= node.value.high && high >= node.value.low) {
                overlaps.push(node.value.value);
            }
            if (node.left && node.left.value.max >= low)
                stack.push(node.left);
            if (node.right && node.right.value.max >= low)
                stack.push(node.right);
        }
        return overlaps;
    };
    return IntervalTree;
}());
exports.IntervalTree = IntervalTree;
