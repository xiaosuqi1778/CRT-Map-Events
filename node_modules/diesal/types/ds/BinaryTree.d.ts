export declare type HasParent<Tree> = Tree & {
    parent: Tree;
    leftmostDescendant: HasParent<Tree>;
    rightmostDescendant: HasParent<Tree>;
};
export declare type HasLeft<Tree> = Tree & {
    left: Tree;
};
export declare type HasRight<Tree> = Tree & {
    right: Tree;
};
export declare type IsRoot<Tree> = Tree & {
    parent: undefined;
};
export declare class BinaryTree<T> {
    value: T;
    parent?: BinaryTree<T>;
    left?: HasParent<BinaryTree<T>>;
    right?: HasParent<BinaryTree<T>>;
    constructor(value: T);
    get size(): number;
    withParent<P extends BinaryTree<T>>(parent: P): this & HasParent<P>;
    withoutParent(): IsRoot<this>;
    setLeft(subtree: BinaryTree<T>): void;
    setRight(subtree: BinaryTree<T>): void;
    get isLeftChild(): boolean;
    get isRightChild(): boolean;
    get leftmostDescendant(): BinaryTree<T>;
    get rightmostDescendant(): BinaryTree<T>;
    prettyPrintValue(): string;
    prettyPrint(indent?: string): string;
    toString(): string;
}
