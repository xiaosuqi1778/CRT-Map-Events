import { BinaryTree, HasParent } from './BinaryTree';
export declare type Comparator<T> = (a: T, b: T) => boolean;
/**
 * A binary search tree is a tree where each node has (at most) two children and
 * the values are sorted. Note that this does not necessarily mean the tree is
 * _balanced_ (see `RBTree` for that), so in the worst case you could have a
 * tree whose depth is the same as its size, meaning worse performance than a
 * simple list.
 */
export declare class BinarySearchTree<T> extends BinaryTree<T> {
    protected cmp: Comparator<T>;
    protected eq: Comparator<T>;
    parent?: BinarySearchTree<T>;
    left?: HasParent<BinarySearchTree<T>>;
    right?: HasParent<BinarySearchTree<T>>;
    constructor(value: T, cmp?: Comparator<T>, eq?: Comparator<T>);
    static fromArray<T>(arr: T[], cmp?: Comparator<T>, eq?: Comparator<T>): BinarySearchTree<T> | undefined;
    findParentAndSideFor(value: T): [BinarySearchTree<T>, 'left' | 'right'];
    insert(value: T): this;
    /**
     * Search for a value in the tree.
     */
    search(value: T): BinarySearchTree<T> | undefined;
    /**
     * Checks if the given value is in the tree.
     *
     * @param {*} value The value to check for
     * @returns {boolean} Whether or not the value is in the collection
     */
    contains(value: T): boolean;
    /**
     * Removes a value from the tree. If the value is in the tree multiple times,
     * it will remove the first one found.
     */
    remove(value: T): BinarySearchTree<T> | undefined;
    /**
     * Finds the immediate predecessor of the given value
     */
    getPredecessor(value: T): T | undefined;
    /**
     * Finds the immediate successor of the given value
     */
    getSuccessor(value: T): T | undefined;
    /**
     * Finds the immediate predecessor or successor of the given value
     */
    private getNeighbor;
}
