import { HasParent } from './BinaryTree';
import { BinarySearchTree, Comparator } from './BinarySearchTree';
/**
 * A Red-Black Tree is a binary search tree that assigns a color to each node
 * (red or black; hence the name). In addition, it maintains these properties:
 *
 * 1. The root is black.
 * 2. Every leaf is black.
 * 3. If a node is red, then both its children are black.
 * 4. For each node, all simple paths from the node to its descendant leaves
 *    contain the same number of black nodes.
 *
 * These properties ensure that the tree is balanced (or close to it) -- in
 * other words, the number of children in the left branch of a node is going to
 * be approximately equal to the number of children in the right branch of the
 * node.
 *
 * Note: Property (2) is implicit; we do not actually create empty nodes and
 * mark them specifically as black in this implementation.
 */
export declare class RBTree<T> extends BinarySearchTree<T> {
    protected cmp: Comparator<T>;
    protected eq: Comparator<T>;
    parent?: RBTree<T>;
    left?: HasParent<RBTree<T>>;
    right?: HasParent<RBTree<T>>;
    protected isRed: boolean;
    constructor(value: T, cmp?: Comparator<T>, eq?: Comparator<T>);
    get color(): 'red' | 'black';
    static fromArray<T>(arr: T[], cmp?: Comparator<T>): RBTree<T> | undefined;
    prettyPrintValue(): string;
    private rotateLeft;
    private rotateRight;
    private insertFixup;
    insert(value: T): this;
    insertAndReturnNode(value: T): RBTree<T>;
    protected transplant(a: RBTree<T>, b: undefined | RBTree<T>): void;
    private deleteFixup;
    remove(value: T): RBTree<T> | undefined;
}
